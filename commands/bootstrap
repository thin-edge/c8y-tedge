#!/usr/bin/env bash
set -e
DEVICE_ID=
TARGET=
OPEN_WEBSITE=${OPEN_WEBSITE:-1}
RENEW_CERT=${RENEW_CERT:-1}
WEBSITE_PAGE="device-info"
SSH_USER=
MAIN_DEVICE=
ENABLE_MTLS=${ENABLE_MTLS:-0}
SCAN=${SCAN:-0}
PATTERN="${PATTERN:-.+}"
BOOTSTRAP_TYPE="${BOOTSTRAP_TYPE:-}"
SUDO=${SUDO:-}
OFFLINE_MODE=${OFFLINE_MODE:-0}
ONE_TIME_PASSWORD=${ONE_TIME_PASSWORD:-}
REMOVE_KNOWN_HOST_ENTRY_ON_FAILURE=${REMOVE_KNOWN_HOST_ENTRY_ON_FAILURE:-1}

usage() {
    EXAMPLES=$(examples 2>&1)
    cat << EOT >&2
Bootstrap a thin-edge.io device using ssh. thin-edge.io will be installed on the device
if it is not already present.
The device must be reachable via ssh on the local network.

The supported bootstrapping methods are described below:

Type: local-ca
1. Create local-ca (if one does not already exist)
2. On the device, create a CSR
3. Sign the CSR (on the host)
4. Copy the public certificate back to the device

Type: self-signed
1. Create the device certificate (if required)
2. Fetch public device certificate and upload it to Cumulocity IoT (private key does not leave the device)
3. Open the device in the Cumulocity IoT Device Management application

Type: --mtls
1. Configure the device as a main device and enforce mTLS for all child devices
2. Create a device-specific signing certificate (if not already done) (stored on the host)
3. Configure the device to trust its signing certificate (that will be used by all its child-devices)
4. Create a local certificate for the main device signed by its signing certificate (as the latter will be trusted by all child-devices)


Type: --mtls --main-device <MAIN_DEVICE>
1. Configure the device as a child device and enforce mTLS for all connections to the main device
2. Create a signing certificate for the main device (if not already done) (stored on the host)
3. Configure the device to trust its main device signing certificate
4. Create a local certificate for the child device signed by the main device signing certificate


USAGE
  c8y tedge bootstrap <TARGET> [DEVICE_ID]

ARGUMENTS
  TARGET              Device hostname or ip to connect to via ssh. E.g. root@mydevice.local
  DEVICE_ID           Device id to be assigned to the device. This will only be used if the device
                      has not already been bootstrapped.

FLAGS
  --skip-renew-cert                        Don't update the certificate of an already connected device
  --skip-website                           Don't open the Cumulocity IoT Device Management application
  --page <STRING>                          Which Device Management page to open. Defaults to device-info
  --type <local-ca|self-signed|c8y-ca|auto>     Certificate signing method. Accepts local-ca, self-signed, auto (default)
  --one-time-password, -p                  One-time password for the Cumulocity certificate-authority bootstrap type.
                                           A random password will be used if one is not provided.
  --mtls                                   Enable mTLS for all local connections over MQTT and HTTP
  --main-device <MAIN_DEVICE>              Main device hostname or ip address to connect to via ssh. This is only used when enabling mTLS on a child device.
  --scan                                   Bootstrap devices found by a scan
  --pattern <REGEX>                        Only include devices which match the given pattern (only applies when piping or scanning devices)
  --offline                                Use offline mode where the cloud connection will not be checked. Ideal if your device does not have internet access
  --verbose                                Enable verbose logging
  --debug                                  Enable debug logging
  -h, --help                               Show this help

$EXAMPLES

EOT
}

examples() {
    cat << EOT >&2
EXAMPLES

# Bootstrap a device via ssh
c8y tedge bootstrap root@mydevice.local

# Bootstrap a device via ssh and forcing the usage of the Cumulocity Certificate Authority (it must already be enabled)
c8y tedge bootstrap root@mydevice.local --type c8y-ca

# Bootstrap a device via ssh, using Cumulocity Certificate Authority and with a user defined one-time password
c8y tedge bootstrap root@mydevice.local --type c8y-ca --one-time-password "ex7s23j4c7687234lk;jO"

# Bootstrap a device via ssh in offline mode (if your device does not have internet access)
c8y tedge bootstrap root@mydevice.local --offline

# Bootstrap a device via ssh using a self signed certificate
c8y tedge bootstrap root@mydevice.local --type self-signed

# Bootstrap a device enabling mTLS
c8y tedge bootstrap root@mydevice.local --mtls

# Bootstrap a child device enabling mTLS
c8y tedge bootstrap root@my-child-device.local --mtls --main-device root@mydevice.local

# Bootstrap a device via ssh but don't open the website
c8y tedge bootstrap root@mydevice.local --skip-website

# Bootstrap any devices found during a scan
c8y tedge bootstrap --ssh-user root --scan --pattern "rpi3"

EOT
}

# Load .env automatically
# Load before parsing arguments so that explicit flags can override any set values
if [ -f .env ]; then
    echo "Loading .env file" >&2
    set -o allexport
    # shellcheck disable=SC1091
    . .env ||:
    set +o allexport
fi

#
# Parse args
#
POSITIONAL_ARGS=()
while [ $# -gt 0 ]; do
    case "$1" in
        --examples)
            examples
            exit 0
            ;;
        --help|-h)
            usage
            exit 0
            ;;
        --page)
            WEBSITE_PAGE="$2"
            shift
            ;;
        --device-id)
            DEVICE_ID="$2"
            shift
            ;;
        --type)
            BOOTSTRAP_TYPE="$2"
            shift
            ;;
        --one-time-password|-p)
            # Only used for Cumulocity CA
            ONE_TIME_PASSWORD="$2"
            shift
            ;;
        --mtls)
            ENABLE_MTLS=1
            ;;
        --main-device)
            MAIN_DEVICE="$2"
            shift
            ;;
        --scan)
            SCAN=1
            ;;
        --pattern)
            PATTERN="$2"
            shift
            ;;
        --ssh-user)
            SSH_USER="$2"
            shift
            ;;
        --offline)
            OFFLINE_MODE=1
            ;;
        --verbose|-v)
            export C8Y_SETTINGS_DEFAULTS_VERBOSE="true"
            ;;
        --debug)
            set -x
            export C8Y_SETTINGS_DEFAULTS_DEBUG="true"
            ;;
        --skip-website)
            OPEN_WEBSITE=0
            ;;
        --skip-renew-cert)
            RENEW_CERT=0
            ;;
        --*|-*)
            printf '\nERROR: Unknown flag. %s\n\n' "$1" >&2
            usage
            exit 1
            ;;
        *)
            POSITIONAL_ARGS+=("$1")
    esac
    shift
done

set -- "${POSITIONAL_ARGS[@]}"

if [ $# -ge 1 ]; then
    TARGET="$1"
fi

if [ $# -ge 2 ]; then
    DEVICE_ID="$2"
fi

supports_c8y_ca() {
    target="$1"
    ENABLED=$(c8y features get --key certificate-authority --select active -o csv ||:)
    if [ "$ENABLED" != true ]; then
        return 1
    fi

    # Apply minimum Cumulocity platform version check
    if [ -z "$(c8y currenttenant version --filter "value version >2025.129.0")" ]; then
        echo "INFO: Cumulocity version must be >2025.129.0 to use the certificate-authority feature" >&2
        return 1
    fi

    if ! "${EXEC_CMD[@]}" "$target" tedge cert download c8y --help >/dev/null 2>&1; then
        return 1
    fi
    return 0
}

detect_bootstrap_type() {
    TARGET="$1"
    # Set default bootstrap type (based on what dependencies are available)
    if [ -z "$BOOTSTRAP_TYPE" ] || [ "$BOOTSTRAP_TYPE" = auto ]; then
        if supports_c8y_ca "$TARGET"; then
            BOOTSTRAP_TYPE=c8y-ca
        elif command -V openssl >/dev/null 2>&1; then
            BOOTSTRAP_TYPE=local-ca
        else
            BOOTSTRAP_TYPE=self-signed
        fi

        echo "Using bootstrap type: $BOOTSTRAP_TYPE" >&2
    fi
}


info() {
    if [ "$C8Y_SETTINGS_DEFAULTS_VERBOSE" = "true" ]; then
        printf "%s\tINFO\t%s" "$(date -Iseconds || true)" "$@" >&2
    fi
}

error() {
    printf "%s\tINFO\t%s" "$(date -Iseconds || true)" "$@" >&2
}

is_ip_address() {
    # TODO: Support IPV6 addresses
    [[ "$1" =~ ^[0-9][0-9]?[0-9]?\.[0-9][0-9]?[0-9]?\.[0-9][0-9]?[0-9]?\.[0-9][0-9]?[0-9]?$ ]]
}

CA_CERT_FILE="${CA_CERT_FILE:-$HOME/tedge-ca.crt}"
CA_CERT_KEY="${CA_CERT_KEY:-$HOME/tedge-ca.key}"
LEAF_EXPIRE_DAYS=365

should_bootstrap_cloud() {
    if [ "$ENABLE_MTLS" = 0 ]; then
        return 0
    fi

    if [ "$ENABLE_MTLS" = 1 ] && [ -z "$MAIN_DEVICE" ]; then
        return 0
    fi
    return 1
}

is_connected() {
    # Check if the bridge is configured because if it isn't that is quicker then checking for connectivity
    if ! "${EXEC_CMD[@]}" "$1" config get c8y.url >/dev/null 2>&1; then
        return 1
    fi

    "${EXEC_CMD[@]}" "$1" tedge connect c8y --test >/dev/null 2>&1
}

create_ca() {
    #
    # Create new ca (signing certificate)
    #
    CA_COMMON_NAME="${CA_COMMON_NAME:-"tedge-ca-$USER"}"
    CA_OU="${CA_OU:-dev}"
    CA_EXPIRE_DAYS="${CA_EXPIRE_DAYS:-365}"

    if [ -f "$CA_CERT_KEY" ] && [ -f "$CA_CERT_FILE" ]; then
        echo "Using existing CA certificate. cert=$CA_CERT_FILE" >&2
    else
        # CN=mkcert reubenmiller@SAG-LJWQ4P62TY (Reuben Miller), OU=reubenmiller@SAG-LJWQ4P62TY (Reuben Miller), O=mkcert development CA
        openssl req \
            -new \
            -x509 \
            -days "$CA_EXPIRE_DAYS" \
            -extensions v3_ca \
            -nodes \
            -subj "/O=thin-edge/OU=dev/CN=$CA_COMMON_NAME" \
            -keyout "$CA_CERT_KEY" \
            -out "$CA_CERT_FILE" >/dev/null 2>&1
    fi

    FINGERPRINT=$(openssl x509 -fingerprint -noout -in "$CA_CERT_FILE" | cut -d= -f2 | tr -d ':' | tr '[:upper:]' '[:lower:]')
    if c8y devicemanagement certificates get --id "$FINGERPRINT" >/dev/null 2>&1; then
        echo "Certificate has already been uploaded to c8y. fingerprint=$FINGERPRINT" >&2
        return
    fi

    if ! c8y devicemanagement certificates create \
        -n \
        --force \
        --name "$CA_COMMON_NAME" \
        --autoRegistrationEnabled \
        --status ENABLED \
        --file "$CA_CERT_FILE" \
        --silentExit --silentStatusCodes 409; then
        echo "failed to upload device certificate" >&2
        exit 1
    fi
    echo "Uploaded certificate" >&2
}

get_subject_alt_names() {
    SUBJECT_ALT_NAMES="DNS:localhost,IP:127.0.0.1"

    while [ $# -gt 0 ]; do
        target="$1"
        shift
        if [ -n "$target" ]; then
            TARGET_WITHOUT_USER="${target//*@/}"
            if is_ip_address "$TARGET_WITHOUT_USER"; then
                SUBJECT_ALT_NAMES="$SUBJECT_ALT_NAMES,IP:$TARGET_WITHOUT_USER"
            else
                # Add both the .local and plain hostname address to the alt names
                SUBJECT_ALT_NAMES="$SUBJECT_ALT_NAMES,DNS:$TARGET_WITHOUT_USER"

                TARGET_WITHOUT_LOCAL="${TARGET_WITHOUT_USER//.local/}"
                if [ "$TARGET_WITHOUT_LOCAL" != "$TARGET_WITHOUT_USER" ]; then
                    SUBJECT_ALT_NAMES="$SUBJECT_ALT_NAMES,DNS:$TARGET_WITHOUT_LOCAL"
                fi
            fi
        fi
    done
    echo "$SUBJECT_ALT_NAMES"
}

create_remote_cert() {
    DEVICE_KEY_PATH=$("${EXEC_CMD[@]}" "$TARGET" $SUDO tedge config get device.key_path)
    DEVICE_CERT_PATH=$("${EXEC_CMD[@]}" "$TARGET" $SUDO tedge config get device.cert_path)

    if ! "${EXEC_CMD[@]}" "$TARGET" test -f "$DEVICE_KEY_PATH"; then
        info "Creating device private key"
        "${EXEC_CMD[@]}" "$TARGET" $SUDO openssl genrsa -out "$DEVICE_KEY_PATH" 2048
    else
        info "Using existing private key"
    fi

    # Create Certificate Signing Request (CSR)
    DEVICE_CSR=$(
        "${EXEC_CMD[@]}" "$TARGET" $SUDO openssl req \
            -key "$DEVICE_KEY_PATH" \
            -new \
            -subj "/O=thin-edge/OU=Test\ Device/CN=${DEVICE_ID}"
    )

    # Protect certificate (after csr is created)
    "${EXEC_CMD[@]}" "$TARGET" $SUDO chown mosquitto:root "$DEVICE_KEY_PATH"
    "${EXEC_CMD[@]}" "$TARGET" $SUDO chmod 600 "$DEVICE_KEY_PATH"


    # Sign the CSR
    CERT_EXT=$(cat << EOF
authorityKeyIdentifier=keyid
basicConstraints=CA:FALSE
keyUsage = digitalSignature, keyAgreement
extendedKeyUsage = serverAuth, clientAuth
subjectAltName=$(get_subject_alt_names "$TARGET")
EOF
    )

    DEVICE_CERT_CHAIN="/tmp/${DEVICE_ID}.crt"
    openssl x509 -req \
        -in <(echo "$DEVICE_CSR") \
        -out "$DEVICE_CERT_CHAIN" \
        -CA "$CA_CERT_FILE" \
        -CAkey "$CA_CERT_KEY" \
        -extfile <(echo "$CERT_EXT") \
        -CAcreateserial \
        -days "$LEAF_EXPIRE_DAYS"

    # Build certificate chain (from leaf cert to the signing cert)
    cat "$CA_CERT_FILE" >> "$DEVICE_CERT_CHAIN"

    # Copy cert to device
    "${SCP_CMD}" "$DEVICE_CERT_CHAIN" "$TARGET" "/tmp/${DEVICE_ID}.crt"
    "${EXEC_CMD[@]}" "$TARGET" sudo mv "/tmp/${DEVICE_ID}.crt" "$DEVICE_CERT_PATH"
    "${EXEC_CMD[@]}" "$TARGET" sudo chown mosquitto:root "$DEVICE_CERT_PATH"
    "${EXEC_CMD[@]}" "$TARGET" sudo chmod 644 "$DEVICE_CERT_PATH"
}

create_self_signed() {
     # Create the device certificate, ignore any errors as this could have already happened
    # Generally the device cert should not be deleted, so just fail silently for now
    if [ -n "$DEVICE_ID" ]; then
        # Use the user given device-id
        "${EXEC_CMD[@]}" "$TARGET" $SUDO tedge cert create --device-id "$DEVICE_ID" 2>/dev/null ||:
    else
        # Default to the hostname of the device
        # shellcheck disable=SC2016
        "${EXEC_CMD[@]}" "$TARGET" $SUDO tedge cert create --device-id '$HOSTNAME' 2>/dev/null ||:
    fi

    # Get public cert
    PUBLIC_CERT=$("${EXEC_CMD[@]}" "$TARGET" cat "\$(tedge config get device.cert_path)")

    if [ -z "$PUBLIC_CERT" ]; then
        echo "Failed to get device certifate from $TARGET" >&2
        exit 1
    fi

    if [ -z "$DEVICE_ID" ]; then
        DEVICE_ID=$("${EXEC_CMD[@]}" "$TARGET" tedge config get device.id)
    fi

    FINGERPRINT=$("${EXEC_CMD[@]}" "$TARGET" tedge cert show | grep Thumbprint | cut -d' ' -f2 | tr '[:upper:]' '[:lower:]')
    if c8y devicemanagement certificates get --id "$FINGERPRINT" >/dev/null 2>&1; then
        echo "Certificate has already been uploaded to c8y. fingerprint=$FINGERPRINT" >&2
        return
    fi

    echo "Certificate CN: $DEVICE_ID" >&2
    if ! c8y devicemanagement certificates create \
        -n \
        --force \
        --name "$DEVICE_ID" \
        --autoRegistrationEnabled \
        --status ENABLED \
        --file <(echo "$PUBLIC_CERT") \
        --silentExit --silentStatusCodes 409; then
        echo "failed to upload device certificate" >&2
        exit 1
    fi
}

register_with_c8y_ca() {
    # Register the device using the Cumulocity certificate-authority feature
    if [ -z "$DEVICE_ID" ]; then
        DEVICE_ID=$("${EXEC_CMD[@]}" "$TARGET" $SUDO tedge cert create --device-id '$HOSTNAME' 2>/dev/null ||:)
    fi

    # Delete in case if the registration already exists
    c8y deviceregistration delete --id "$DEVICE_ID" --force >/dev/null 2>&1 ||:

    if [ -z "$ONE_TIME_PASSWORD" ]; then
        ONE_TIME_PASSWORD=$(c8y template execute --template "_.PasswordUrlSafe(31)")
    fi
    c8y deviceregistration register-ca --id "$DEVICE_ID" --one-time-password "$ONE_TIME_PASSWORD"
    "${EXEC_CMD[@]}" "$TARGET" $SUDO tedge cert download c8y --device-id "$DEVICE_ID" --one-time-password "$ONE_TIME_PASSWORD" --retry-every 5s --max-timeout 30s  2>/dev/null ||:
}

# Create a signing certificate for a main device
#
# This certificate is used to sign all the entities related to a main device.
# It's deployed on the main device and all its child devices (and possibly grand-child devices).
# It's used to let the child devices authenticate the main device end-points (the local bus, the file transfer service or the c8y proxy).
# It's used by the main device to authenticate child devices.
#
# The associated private key is stored on the host running the `c8y tedge` command - not the main device.
create_signing_cert() {
    MAIN_DEVICE_ID=$1
    if [ -z "$MAIN_DEVICE_ID" ]; then
        echo "mTLS cannot be enabled without an id for the main device" >&2
        exit 1
    fi

    SIGNING_CERT_DIR="${HOME}/.tedge/device-signing-certs"
    SIGNING_CERT_NAME="${MAIN_DEVICE_ID}-local-ca"
    SIGNING_CERT_FILE="${SIGNING_CERT_DIR}/${SIGNING_CERT_NAME}.crt"
    SIGNING_CERT_KEY="${SIGNING_CERT_DIR}/${SIGNING_CERT_NAME}.key"
    CA_EXPIRE_DAYS="${CA_EXPIRE_DAYS:-365}"

    mkdir -p "$SIGNING_CERT_DIR"

    if [ -f "$SIGNING_CERT_FILE" ] && [ -f "$SIGNING_CERT_KEY" ]; then
        echo "Using existing device local CA certificate: $SIGNING_CERT_FILE" >&2
    else
        echo "Creating new device local CA certificate: $SIGNING_CERT_FILE" >&2
        openssl req \
            -new \
            -x509 \
            -days "$CA_EXPIRE_DAYS" \
            -extensions v3_ca \
            -nodes \
            -subj "/O=thin-edge/OU=local-ca/CN=${SIGNING_CERT_NAME}" \
            -keyout "$SIGNING_CERT_KEY" \
            -out "$SIGNING_CERT_FILE" >/dev/null 2>&1
    fi

    # Upload the signing CA on the target
    LOCAL_CERT_DIR=/etc/tedge/device-certs/local-certs
    LOCAL_SIGNING_CERT_FILE="${LOCAL_CERT_DIR}/${SIGNING_CERT_NAME}.crt"

    "${SCP_CMD}" "$SIGNING_CERT_FILE" "$TARGET" "/tmp/${SIGNING_CERT_NAME}.crt"
    "${EXEC_CMD[@]}" "$TARGET" "$SUDO" mkdir -p "$LOCAL_CERT_DIR"
    "${EXEC_CMD[@]}" "$TARGET" "$SUDO" mv "/tmp/${SIGNING_CERT_NAME}.crt" "$LOCAL_SIGNING_CERT_FILE"

    # Make the signing certificate trusted by the device
    "${EXEC_CMD[@]}" "$TARGET" "$SUDO" mkdir -p "/usr/local/share/ca-certificates"
    "${EXEC_CMD[@]}" "$TARGET" "$SUDO" cp "$LOCAL_SIGNING_CERT_FILE" "/usr/local/share/ca-certificates"
    "${EXEC_CMD[@]}" "$TARGET" "$SUDO" sh -c "command -V update-ca-certificates >/dev/null 2>&1 && update-ca-certificates"
}

# Create a certificate that is trusted by all the entities attached to a main device
#
# This certificate is created on the target device,
# but signed on the host running the `c8y tedge` command on behalf of the main device.
create_local_cert() {
    MAIN_DEVICE_ID=$1
    SERVICE=$2
    if [ -z "$MAIN_DEVICE_ID" ]; then
        echo "mTLS cannot be enabled without an id for the main device" >&2
        exit 1
    fi
    if [ -z "$SERVICE" ]; then
        SERVICE=main-agent
    fi

    # Prepare required info for subjectAltName
    TARGET_DNS=
    TARGET_IP=
    TARGET_WITHOUT_USER="${TARGET//*@/}"

    if is_ip_address "$TARGET_WITHOUT_USER"; then
        TARGET_IP="$TARGET_WITHOUT_USER"
    else
        TARGET_DNS="$TARGET_WITHOUT_USER"
    fi

    if [ -z "$TARGET_DNS" ]; then
        TARGET_DNS=$("${EXEC_CMD[@]}" "$TARGET" hostname 2>/dev/null || true)
    fi

    if [ -z "$TARGET_IP" ]; then
        TARGET_IP=$("${EXEC_CMD[@]}" "$TARGET" "ip route get 8.8.8.8 2>/dev/null | sed -E 's/.*src (\S+) .*/\1/;t;d' 2>/dev/null || true")
    fi

    # Prepare cert files
    SIGNING_CERT_DIR="${HOME}/.tedge/device-signing-certs"
    SIGNING_CERT_NAME="${MAIN_DEVICE_ID}-local-ca"
    SIGNING_CERT_FILE="${SIGNING_CERT_DIR}/${SIGNING_CERT_NAME}.crt"
    SIGNING_CERT_KEY="${SIGNING_CERT_DIR}/${SIGNING_CERT_NAME}.key"
    CA_EXPIRE_DAYS="${CA_EXPIRE_DAYS:-365}"

    LOCAL_CERT_DIR=/etc/tedge/device-certs/local-certs
    LOCAL_CERT_NAME="${DEVICE_ID}-${SERVICE}"
    LOCAL_CERT_FILE="${LOCAL_CERT_DIR}/${LOCAL_CERT_NAME}.crt"
    LOCAL_CERT_KEY="${LOCAL_CERT_DIR}/${LOCAL_CERT_NAME}.key"
    LOCAL_SIGNING_CERT_FILE="${LOCAL_CERT_DIR}/${SIGNING_CERT_NAME}.crt"

    "${EXEC_CMD[@]}" "$TARGET" mkdir -p "$LOCAL_CERT_DIR"

    if ! "${EXEC_CMD[@]}" "$TARGET" test -f "$LOCAL_CERT_KEY"; then
        info "Creating device private key"
        "${EXEC_CMD[@]}" "$TARGET" $SUDO openssl genrsa -out "$LOCAL_CERT_KEY" 2048
        "${EXEC_CMD[@]}" "$TARGET" sudo chown tedge:root "$LOCAL_CERT_KEY"
        "${EXEC_CMD[@]}" "$TARGET" sudo chmod 400 "$LOCAL_CERT_KEY"
    else
        info "Using existing private key"
    fi

    # Create Certificate Signing Request (CSR)
    DEVICE_CSR=$(
        "${EXEC_CMD[@]}" "$TARGET" $SUDO openssl req \
            -key "$LOCAL_CERT_KEY" \
            -new \
            -subj "/O=thin-edge/OU=${DEVICE_ID}/CN=${SERVICE}"
    )

    # Sign the CSR
    if [ "$SERVICE" = "child-agent" ]; then
        CERT_EXT=$(cat << EOF
basicConstraints=CA:FALSE
extendedKeyUsage = clientAuth
EOF
    )
    else
        CERT_EXT=$(cat << EOF
authorityKeyIdentifier=keyid
basicConstraints=CA:FALSE
keyUsage = digitalSignature, keyAgreement
extendedKeyUsage = serverAuth, clientAuth
subjectAltName = $(get_subject_alt_names "$TARGET_IP" "$TARGET_DNS")
EOF
    )
    fi

    DEVICE_CERT_CHAIN="/tmp/${LOCAL_CERT_NAME}.crt"
    openssl x509 -req \
        -in <(echo "$DEVICE_CSR") \
        -out "$DEVICE_CERT_CHAIN" \
        -CA "$SIGNING_CERT_FILE" \
        -CAkey "$SIGNING_CERT_KEY" \
        -extfile <(echo "$CERT_EXT") \
        -CAcreateserial \
        -days "$LEAF_EXPIRE_DAYS"

    # Build certificate chain (from leaf cert to the signing cert)
    cat "$SIGNING_CERT_FILE" >> "$DEVICE_CERT_CHAIN"

    # Copy cert to device
    "${SCP_CMD}" "$DEVICE_CERT_CHAIN" "$TARGET" "/tmp/${LOCAL_CERT_NAME}.crt"
    "${EXEC_CMD[@]}" "$TARGET" "$SUDO" mv "/tmp/${LOCAL_CERT_NAME}.crt" "$LOCAL_CERT_FILE"
    "${EXEC_CMD[@]}" "$TARGET" "$SUDO" chown tedge:root "$LOCAL_CERT_FILE"
    "${EXEC_CMD[@]}" "$TARGET" "$SUDO" chmod 644 "$LOCAL_CERT_FILE"

    case "$SERVICE" in
        mqtt-broker)
            configure_mtls_mqtt_broker "$TARGET_IP" "$TARGET_DNS" "$LOCAL_SIGNING_CERT_FILE" "$LOCAL_CERT_FILE" "$LOCAL_CERT_KEY"
            ;;
        main-agent)
            configure_mtls_mqtt_client "$TARGET_IP" "$TARGET_DNS" "$LOCAL_SIGNING_CERT_FILE" "$LOCAL_CERT_FILE" "$LOCAL_CERT_KEY"
            configure_mtls_main_agent "$TARGET_IP" "$TARGET_DNS" "$LOCAL_CERT_FILE" "$LOCAL_CERT_KEY"
            ;;
        c8y-mapper)
            configure_mtls_c8y_mapper "$TARGET_IP" "$TARGET_DNS" "$LOCAL_CERT_FILE" "$LOCAL_CERT_KEY"
            ;;
        child-agent)
	        # GET IP and DNS of the main device
            MAIN_DEVICE_IP=
            MAIN_DEVICE_DNS=
            MAIN_DEVICE_WITHOUT_USER="${MAIN_DEVICE//*@/}"

            if is_ip_address "$MAIN_DEVICE_WITHOUT_USER"; then
                MAIN_DEVICE_IP="$MAIN_DEVICE_WITHOUT_USER"
            else
                MAIN_DEVICE_DNS="$MAIN_DEVICE_WITHOUT_USER"
            fi

            if [ -z "$MAIN_DEVICE_DNS" ]; then
                MAIN_DEVICE_DNS=$("${EXEC_CMD[@]}" "$MAIN_DEVICE" hostname 2>/dev/null || true)
            fi
            if [ -z "$MAIN_DEVICE_IP" ]; then
                MAIN_DEVICE_IP=$("${EXEC_CMD[@]}" "$MAIN_DEVICE" "ip route get 8.8.8.8 2>/dev/null | sed -E 's/.*src (\S+) .*/\1/;t;d' 2>/dev/null || true")
            fi
            configure_mtls_mqtt_client "$MAIN_DEVICE_IP" "$MAIN_DEVICE_DNS" "$LOCAL_SIGNING_CERT_FILE" "$LOCAL_CERT_FILE" "$LOCAL_CERT_KEY"
            configure_mtls_child_agent "$MAIN_DEVICE_IP" "$MAIN_DEVICE_DNS" "$LOCAL_CERT_FILE" "$LOCAL_CERT_KEY"
            ;;
        *)
            ;;
    esac
}

# configure tegde-agent on the main device
configure_mtls_main_agent() {
    TARGET_IP="$1"
    TARGET_DNS="$2"
    LOCAL_CERT_FILE="$3"
    LOCAL_CERT_KEY="$4"

    # tedge-agent acts as a server for file-transfer	
    "${EXEC_CMD[@]}" "$TARGET" $SUDO tedge config set http.bind.address 0.0.0.0
    "${EXEC_CMD[@]}" "$TARGET" $SUDO tedge config set http.bind.port "8000"
    "${EXEC_CMD[@]}" "$TARGET" $SUDO tedge config set http.cert_path "$LOCAL_CERT_FILE"
    "${EXEC_CMD[@]}" "$TARGET" $SUDO tedge config set http.key_path "$LOCAL_CERT_KEY"
    "${EXEC_CMD[@]}" "$TARGET" $SUDO tedge config set http.ca_path /etc/ssl/certs

    # tedge-agent is a client of c8y-proxy	
    "${EXEC_CMD[@]}" "$TARGET" $SUDO tedge config set c8y.proxy.client.host "$TARGET_IP"
    "${EXEC_CMD[@]}" "$TARGET" $SUDO tedge config set c8y.proxy.client.port "8001"

    # apply the new config
    echo "Restart tedge-agent on ${TARGET_DNS}" >&2
    "${EXEC_CMD[@]}" "$TARGET" $SUDO systemctl restart tedge-agent
}

configure_mtls_c8y_mapper() {
    TARGET_IP="$1"
    TARGET_DNS="$2"
    LOCAL_CERT_FILE="$3"
    LOCAL_CERT_KEY="$4"

    # c8y-mapper acts as a server for c8y proxy
    "${EXEC_CMD[@]}" "$TARGET" $SUDO tedge config set c8y.proxy.bind.address 0.0.0.0
    "${EXEC_CMD[@]}" "$TARGET" $SUDO tedge config set c8y.proxy.bind.port "8001"
    "${EXEC_CMD[@]}" "$TARGET" $SUDO tedge config set c8y.proxy.cert_path "$LOCAL_CERT_FILE"
    "${EXEC_CMD[@]}" "$TARGET" $SUDO tedge config set c8y.proxy.key_path "$LOCAL_CERT_KEY"
    "${EXEC_CMD[@]}" "$TARGET" $SUDO tedge config set c8y.proxy.ca_path /etc/ssl/certs

    # c8y-mapper is a client of file-transfer
    "${EXEC_CMD[@]}" "$TARGET" $SUDO tedge config set http.client.host "$TARGET_IP"
    "${EXEC_CMD[@]}" "$TARGET" $SUDO tedge config set http.client.port "8000"
    "${EXEC_CMD[@]}" "$TARGET" $SUDO tedge config set http.client.auth.cert_file "$LOCAL_CERT_FILE"
    "${EXEC_CMD[@]}" "$TARGET" $SUDO tedge config set http.client.auth.key_file "$LOCAL_CERT_KEY"

    # apply the new config
    echo "Restart tedge-mapper-c8y on ${TARGET_DNS}" >&2
    "${EXEC_CMD[@]}" "$TARGET" $SUDO systemctl restart tedge-mapper-c8y
}

configure_mtls_child_agent() {
    MAIN_DEVICE_IP="$1"
    MAIN_DEVICE_DNS="$2"
    LOCAL_CERT_FILE="$3"
    LOCAL_CERT_KEY="$4"

    # child_agent is a client of c8y-proxy	
    "${EXEC_CMD[@]}" "$TARGET" $SUDO tedge config set c8y.proxy.client.host "$MAIN_DEVICE_IP"
    "${EXEC_CMD[@]}" "$TARGET" $SUDO tedge config set c8y.proxy.client.port "8001"

    # child_agent is a client of file-transfer
    "${EXEC_CMD[@]}" "$TARGET" $SUDO tedge config set http.client.host "$MAIN_DEVICE_IP"
    "${EXEC_CMD[@]}" "$TARGET" $SUDO tedge config set http.client.port "8000"
    "${EXEC_CMD[@]}" "$TARGET" $SUDO tedge config set http.client.auth.cert_file "$LOCAL_CERT_FILE"
    "${EXEC_CMD[@]}" "$TARGET" $SUDO tedge config set http.client.auth.key_file "$LOCAL_CERT_KEY"

    # apply the new config
    echo "Restart tedge-agent on ${TARGET_DNS}" >&2
    "${EXEC_CMD[@]}" "$TARGET" $SUDO systemctl restart tedge-agent
}

# configure mosquitto on the main device
configure_mtls_mqtt_broker() {
    TARGET_IP="$1"
    TARGET_DNS="$2"
    SIGNING_CERT_FILE="$3"
    LOCAL_CERT_FILE="$4"
    LOCAL_CERT_KEY="$5"

    ## Move under /etc/mosquitto/ca_certificates/ all the mosquitto related certificates

    "${EXEC_CMD[@]}" "$TARGET" "$SUDO" cp "$SIGNING_CERT_FILE" /etc/mosquitto/ca_certificates/
    SIGNING_CERT_FILE="/etc/mosquitto/ca_certificates/$(basename "$SIGNING_CERT_FILE")"
    "${EXEC_CMD[@]}" "$TARGET" "$SUDO" chmod 444 "$SIGNING_CERT_FILE"
    "${EXEC_CMD[@]}" "$TARGET" "$SUDO" chown mosquitto:mosquitto "$SIGNING_CERT_FILE"

    "${EXEC_CMD[@]}" "$TARGET" "$SUDO" mv "$LOCAL_CERT_FILE" /etc/mosquitto/ca_certificates/
    LOCAL_CERT_FILE="/etc/mosquitto/ca_certificates/$(basename "$LOCAL_CERT_FILE")"
    "${EXEC_CMD[@]}" "$TARGET" "$SUDO" chmod 444 "$LOCAL_CERT_FILE"
    "${EXEC_CMD[@]}" "$TARGET" "$SUDO" chown mosquitto:mosquitto "$LOCAL_CERT_FILE"

    "${EXEC_CMD[@]}" "$TARGET" "$SUDO" mv "$LOCAL_CERT_KEY" /etc/mosquitto/ca_certificates/
    LOCAL_CERT_KEY="/etc/mosquitto/ca_certificates/$(basename "$LOCAL_CERT_KEY")"
    "${EXEC_CMD[@]}" "$TARGET" "$SUDO" chmod 400 "$LOCAL_CERT_KEY"
    "${EXEC_CMD[@]}" "$TARGET" "$SUDO" chown mosquitto:mosquitto "$LOCAL_CERT_KEY"

    ## FIXME: For now nothing is changed on the host itself (so other tools, such as collectd, can connect as before)
    ##
    # Unset previously set bind address/port in cases users had previously set it to 0.0.0.0
    "${EXEC_CMD[@]}" "$TARGET" $SUDO tedge config unset mqtt.bind.address
    "${EXEC_CMD[@]}" "$TARGET" $SUDO tedge config unset mqtt.bind.port

    ## FIXME: Mosquitto configuration generated with `mqtt.external` is incorrect
    ##        see https://github.com/thin-edge/thin-edge.io/issues/2740
    ##
    ## "${EXEC_CMD[@]}" "$TARGET" $SUDO tedge config set mqtt.external.bind.address "$TARGET_IP"
    ## "${EXEC_CMD[@]}" "$TARGET" $SUDO tedge config set mqtt.external.bind.port 1883
    ## "${EXEC_CMD[@]}" "$TARGET" $SUDO tedge config set mqtt.external.ca_path "$SIGNING_CERT_FILE"
    ## "${EXEC_CMD[@]}" "$TARGET" $SUDO tedge config set mqtt.external.cert_file "$LOCAL_CERT_FILE"
    ## "${EXEC_CMD[@]}" "$TARGET" $SUDO tedge config set mqtt.external.key_file "$LOCAL_CERT_KEY"

    ## As a workaround the configuration for external settings is created independently without `tedge`

    cat << EOF >"/tmp/${DEVICE_ID}-tls-listener.conf"
listener 8883 0.0.0.0
allow_anonymous false
require_certificate true
use_identity_as_username true
use_username_as_clientid false
cafile ${SIGNING_CERT_FILE}
certfile ${LOCAL_CERT_FILE}
keyfile ${LOCAL_CERT_KEY}
EOF

    "${SCP_CMD}" "/tmp/${DEVICE_ID}-tls-listener.conf" "$TARGET" "/tmp/tls-listener.conf"
    "${EXEC_CMD[@]}" "$TARGET" "$SUDO" mv "/tmp/tls-listener.conf" /etc/mosquitto/conf.d
    "${EXEC_CMD[@]}" "$TARGET" "$SUDO" chown mosquitto:mosquitto /etc/mosquitto/conf.d/tls-listener.conf
    "${EXEC_CMD[@]}" "$TARGET" "$SUDO" chmod 644 /etc/mosquitto/conf.d/tls-listener.conf

    # apply the new config
    echo "Restart mosquitto on ${TARGET_DNS}" >&2
    "${EXEC_CMD[@]}" "$TARGET" $SUDO systemctl restart mosquitto
}

# configure mqtt on a child device
configure_mtls_mqtt_client() {
    TARGET_IP="$1"
    TARGET_DNS="$2"
    SIGNING_CERT_FILE="$3"
    LOCAL_CERT_FILE="$4"
    LOCAL_CERT_KEY="$5"

    if [ -z "$MAIN_DEVICE" ]; then
        "${EXEC_CMD[@]}" "$TARGET" $SUDO tedge config set mqtt.device_topic_id "device/main//"
    else
        # TODO: Should other services be stopped/disabled on a child device automatically
        # (in case the device was previously setup with thin-edge.io main device installed)
        "${EXEC_CMD[@]}" "$TARGET" $SUDO tedge config set mqtt.device_topic_id "device/$DEVICE_ID//"
    fi

    # TODO: Support using a hostname once https://github.com/thin-edge/thin-edge.io/issues/2803 is resolved
    # to be more flexible if the ip address changes over time (e.g. DHCP)
    "${EXEC_CMD[@]}" "$TARGET" $SUDO tedge config set mqtt.client.host "$TARGET_IP"
    "${EXEC_CMD[@]}" "$TARGET" $SUDO tedge config set mqtt.client.port 8883
    "${EXEC_CMD[@]}" "$TARGET" $SUDO tedge config set mqtt.client.auth.ca_file "$SIGNING_CERT_FILE"
    "${EXEC_CMD[@]}" "$TARGET" $SUDO tedge config set mqtt.client.auth.cert_file "$LOCAL_CERT_FILE"
    "${EXEC_CMD[@]}" "$TARGET" $SUDO tedge config set mqtt.client.auth.key_file "$LOCAL_CERT_KEY"
}

c8y_bulk_registration() {
    EXTERNAL_ID="$1"
    DEVICE_TYPE="thin-edge.io"
    if [ $# -gt 1 ]; then
        DEVICE_TYPE="$2"
    fi

    REG_FILE="/tmp/${EXTERNAL_ID}.csv"

    cat << EOT > "$REG_FILE"
"ID","AUTH_TYPE","TYPE","NAME","com_cumulocity_model_Agent.active"
"$EXTERNAL_ID",CERTIFICATES,"$DEVICE_TYPE","$EXTERNAL_ID",true
EOT

    echo "Manually registering device: $EXTERNAL_ID (type=$DEVICE_TYPE)" >&2
    if ! c8y api POST devicecontrol/bulkNewDeviceRequests --file "$REG_FILE" --force; then
        echo "Warning: Failed to manually register device (via c8y bulk registration API): $EXTERNAL_ID" >&2
        exit 1
    fi
    rm -f "$REG_FILE"
}

get_device_id() {
    # Get identity (stop on first non empty value)
    target="$1"
    device_id="$2"
    _device_id_method=1
    while [ -z "$device_id" ]; do
        case "$_device_id_method" in
            1)
                # use the existing value
                info "Trying to get identity using tedge config"
                device_id=$("${EXEC_CMD[@]}" "$target" tedge config get device.id 2>/dev/null || true)
                ;;
            2)
                # try using tedge-identity
                info "Trying to get identity using tedge-identity"
                device_id=$("${EXEC_CMD[@]}" "$target" tedge-identity 2>/dev/null || true)
                ;;
            3)
                # hostname
                info "Trying to get identity using hostname"
                device_id=$("${EXEC_CMD[@]}" "$target" hostname 2>/dev/null || true)
                ;;
            *)
                break
                ;;
        esac
        ((_device_id_method++))
    done
    echo "$device_id"
}


EXEC_CMD=(
    ssh
    -n
)

remote_scp() {
    scp "$1" "$2:$3"
}

SCP_CMD=remote_scp

# NOTE: Some SSH services (like dropbear) don't inherit the PATH variable, so it results in some false
# negatives when tedge tries to detect the mosquitto version, e.g.:
#   Failed to detect mosquitto version: assuming mosquitto version < 2.0.0
#
REMOTE_PATH="PATH=\$PATH:/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin"

check_ssh_connection() {
    target="$1"
    host="${target#*@}"

    if "${EXEC_CMD[@]}" "$target" $SUDO echo "SSH Connection successful"; then
        return 0
    fi

    if [ "$REMOVE_KNOWN_HOST_ENTRY_ON_FAILURE" = 1 ]; then
        if command -V ssh-keygen >/dev/null 2>&1; then
            if ssh-keygen -R "$host"; then
                echo "Removed device from ssh known_hosts" >&2

                # Try again to connect
                if "${EXEC_CMD[@]}" "$target" $SUDO echo "SSH Connection successful"; then
                    return 0
                fi
            fi
        fi
    fi

    echo "Failed to connect to device. target=$target" >&2
    return 1
}

install_tedge_if_missing() {
    if ! "${EXEC_CMD[@]}" "$target" tedge --version; then
        echo "Installing thin-edge.io as it is missing on the device ($target)" >&2
        "${EXEC_CMD[@]}" "$target" sh -c \'wget -O - thin-edge.io/install.sh | sh -s\'
    fi
}

do_action() {
    if [ $# -gt 0 ]; then
        TARGET="$1"
    fi
    if [ -n "$MAIN_DEVICE" ]; then
        MAIN_DEVICE_ID=$(get_device_id "$MAIN_DEVICE")
    fi
    if [ -n "$SSH_USER" ]; then
         TARGET="$SSH_USER@$TARGET"
    fi

    # Don't use sudo if the user is root
    case "$TARGET" in
        root)
            SUDO=
            ;;
        *)
            SUDO=sudo
            ;;
    esac

    # TODO: Check if the device is already connected or not, otherwise this command will fail if the url is already set.
    # shellcheck disable=SC2029
    URL=
    if [ -n "$C8Y_DOMAIN" ]; then
        URL="$C8Y_DOMAIN"
    else
        URL=$(c8y sessions get --select host -o csv | sed -E 's|https?://||')
    fi

    # Check if an ssh connection can be established to the device, if not fail early
    if ! check_ssh_connection "$TARGET"; then
        echo "Could not connect to the device. Aborting. device=$TARGET" >&2
        exit 1
    fi

    # Install thin-edge.io
    install_tedge_if_missing
    detect_bootstrap_type "$TARGET"

    # Get identity
    DEVICE_ID=$(get_device_id "$TARGET" "$DEVICE_ID")
    if [ -z "$DEVICE_ID" ]; then
        echo "Could not detect a device id" >&2
        exit 1
    fi

    if [ "$ENABLE_MTLS" = "1" ]; then
        if ! command -V openssl >/dev/null 2>&1; then
            echo "Missing dependency: openssl is not installed" >&2
            exit 1
        fi
        if [ -z "$MAIN_DEVICE" ]; then
            # enabling mTLS on the main device
            create_signing_cert "$DEVICE_ID"
            create_local_cert "$DEVICE_ID" mqtt-broker
            create_local_cert "$DEVICE_ID" main-agent
            create_local_cert "$DEVICE_ID" c8y-mapper
        else
            # enabling mTLS on a child device
            create_signing_cert "$MAIN_DEVICE_ID"
            create_local_cert "$MAIN_DEVICE_ID" child-agent
        fi
    fi

    # Disconnect if tedge is already connected
    # Note: Check if the mapper is configured or not but it can't be assumed that it is successfully configured
    if should_bootstrap_cloud; then
        IS_CONNECTED=$(is_connected "$TARGET" && echo "1" || echo "0")
        if [ "$RENEW_CERT" = 0 ] && [ "$IS_CONNECTED" = 1 ]; then
            echo "tedge is already connected, skipping certificate generation" >&2
        else
            # ensure that tedge is disconnected before setting url and generating new certificate
            "${EXEC_CMD[@]}" "$TARGET" $SUDO tedge disconnect c8y ||:
            echo "Setting tedge c8y.url to $URL" >&2
            "${EXEC_CMD[@]}" "$TARGET" $SUDO tedge config set c8y.url "$URL"

            case "$BOOTSTRAP_TYPE" in
                    self-signed)
                        create_self_signed
                        ;;
                    local-ca)
                        if ! command -V openssl >/dev/null 2>&1; then
                            echo "Missing dependency: openssl is not installed" >&2
                            exit 1
                        fi
                        create_ca
                        create_remote_cert
                        ;;
                    c8y-ca)
                        if ! register_with_c8y_ca; then
                            echo "Failed to register device with the Cumulocity Certificate Authority" >&2
                            exit 1
                        fi
                        ;;
                    *)
                        echo "Unknown bootstrapping method" >&2
                        exit 1
                        ;;
            esac
        fi

        # In offline mode, just configure the bridge, do not test the connection as the device may not have internet
        if [ "$OFFLINE_MODE" = 1 ]; then
            echo "Bootstrapping thin-edge.io in OFFLINE mode" >&2

            # Register device via c8y bulk registration api because "tedge connect c8y" doesn't do it
            c8y_bulk_registration "$DEVICE_ID"

            if ! "${EXEC_CMD[@]}" "$TARGET" $SUDO PATH="$REMOTE_PATH" tedge connect c8y --offline; then
                echo "Offline mode requires thin-edge.io >= 1.1.0. Please upgrade and try again" >&2
                exit 1
            fi
            exit 0
        fi

        # Wait for certificate to be enabled
        if ! "${EXEC_CMD[@]}" "$TARGET" $SUDO PATH="$REMOTE_PATH" tedge connect c8y --test >/dev/null 2>&1; then
            sleep 2

            attempt=0
            max_attempts=10
            success=0
            while [ "$attempt" -lt "$max_attempts" ]; do
                if "${EXEC_CMD[@]}" "$TARGET" $SUDO PATH="$REMOTE_PATH" tedge reconnect c8y; then
                    success=1
                    break
                fi

                echo "Connection failed. Trying again in 5 seconds" >&2
                sleep 5
            done

            if [ "$success" = "1" ]; then
                echo "Successfully bootstrapped device" >&2
            else
                echo "Bootstrapping failed. Please check the console output for more details" >&2
            fi
        fi

        # Open device management page for the device
        if [ "$OPEN_WEBSITE" = 1 ]; then
            c8y identity get -n --name "$DEVICE_ID" --retries 5 | c8y applications open --application devicemanagement --page "$WEBSITE_PAGE"
        fi
    fi
}


DEVICES=()

if [ ! -t 0 ]; then
    echo "Reading from pipeline" >&2
    while IFS= read -r device; do
        if [ -n "$device" ] && [[ "${device}" =~ $PATTERN ]]; then
            DEVICES+=("$device")
        fi
    done < <(cat -)
elif [ "$SCAN" = 1 ]; then
    echo "Scanning for devices" >&2
    while read -r device; do
        if [ -n "$device" ] && [[ "${device}" =~ $PATTERN ]]; then
            DEVICES+=("$device")
        fi
    done < <(c8y tedge scan --timeout 2)
else
    echo "Using user provided device" >&2
    DEVICES+=("$TARGET")
fi


case "${#DEVICES[@]}" in
    0)
        echo "No devices were found" >&2
        ;;
    1)
        echo "Found ${#DEVICES[@]} device" >&2
        ;;
    *)
        echo "Found ${#DEVICES[@]} devices" >&2
        ;;
esac

for device in "${DEVICES[@]}"; do
    do_action "$device"
done
